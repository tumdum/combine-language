var searchIndex = {};
searchIndex["combine_language"] = {"doc":"# Example","items":[[3,"Lex","combine_language","A lexing parser for a language",null,null],[3,"WhiteSpace","","A whitespace parser for a language",null,null],[3,"Reserved","","Parses a reserved word",null,null],[3,"BetweenChar","","Parses `P` between two delimiter characters",null,null],[3,"Identifier","","Defines how to define an identifier (or operator)",null,null],[12,"start","","Parses a valid starting character for an identifier",0,null],[12,"rest","","Parses the rest of the characthers in a valid identifier",0,null],[12,"reserved","","A number of reserved words which cannot be identifiers",0,null],[3,"LanguageDef","","A struct type which contains the necessary definitions to construct a language parser",null,null],[12,"ident","","How to parse an identifier",1,null],[12,"op","","How to parse an operator",1,null],[12,"comment_line","","Describes the start of a line comment",1,null],[12,"comment_start","","Describes the start of a block comment",1,null],[12,"comment_end","","Describes the end of a block comment",1,null],[3,"LanguageEnv","","A type containing parsers for a specific language.\nFor some parsers there are two version where the parser which ends with a `_` is a variant\nwhich does not skip whitespace and comments after parsing the token itself.",null,null],[3,"Assoc","","Struct for encompassing the associativity of an operator",null,null],[12,"fixity","","Operator fixity",2,null],[12,"precedence","","Operator precedence",2,null],[3,"Expression","","Expression parser which handles binary operators",null,null],[4,"Fixity","","Enumeration on fixities for the expression parser",null,null],[13,"Left","","",3,null],[13,"Right","","",3,null],[5,"expression_parser","","Constructs an expression parser out of a term parser, an operator parser and a function which\ncombines a binary expression to new expressions.",null,{"inputs":[{"name":"p"},{"name":"o"},{"name":"f"}],"output":{"name":"expression"}}],[6,"LanguageParser","","",null,null],[6,"LexLanguageParser","","",null,null],[11,"clone","","",4,null],[11,"parse_stream","","",4,null],[11,"parse_stream_consumed","","",4,null],[11,"parse_lazy","","",4,null],[11,"add_error","","",4,null],[11,"clone","","",5,null],[11,"parse_stream","","",5,null],[11,"parse_stream","","",6,null],[11,"parse_stream_consumed","","",6,null],[11,"parse_lazy","","",6,null],[11,"add_error","","",6,null],[11,"parse_stream","","",7,null],[11,"parse_stream_consumed","","",7,null],[11,"parse_lazy","","",7,null],[11,"add_error","","",7,null],[11,"new","","Constructs a new parser from a language defintion",8,{"inputs":[{"name":"languagedef"}],"output":{"name":"languageenv"}}],[11,"lex","","Creates a lexing parser from `p`",8,null],[11,"white_space","","Skips spaces and comments",8,null],[11,"symbol","","Parses a symbol, lexing the stream if it is successful",8,null],[11,"identifier","","Parses an identifier, failing if it parses something that is a reserved identifier",8,null],[11,"identifier_","","",8,null],[11,"range_identifier","","Parses an identifier, failing if it parses something that is a reserved identifier",8,null],[11,"range_identifier_","","",8,null],[11,"reserved","","Parses the reserved identifier `name`",8,null],[11,"op","","Parses an operator, failing if it parses something that is a reserved operator",8,null],[11,"op_","","",8,null],[11,"range_op","","Parses an identifier, failing if it parses something that is a reserved identifier",8,null],[11,"range_op_","","",8,null],[11,"reserved_op","","Parses the reserved operator `name`",8,null],[11,"reserved_op_","","",8,null],[11,"char_literal","","Parses a character literal taking escape sequences into account",8,null],[11,"char_literal_","","",8,null],[11,"string_literal","","Parses a string literal taking character escapes into account",8,null],[11,"string_literal_","","",8,null],[11,"angles","","Parses `p` inside angle brackets\n`&lt; p &gt;`",8,null],[11,"braces","","Parses `p` inside braces\n`{ p }`",8,null],[11,"brackets","","Parses `p` inside brackets\n`[ p ]`",8,null],[11,"parens","","Parses `p` inside parentheses\n`( p )`",8,null],[11,"integer","","Parses an integer",8,null],[11,"integer_","","",8,null],[11,"float","","Parses a floating point number",8,null],[11,"float_","","",8,null],[11,"fmt","","",3,null],[11,"partial_cmp","","",3,null],[11,"cmp","","",3,null],[11,"eq","","",3,null],[11,"clone","","",3,null],[11,"fmt","","",2,null],[11,"partial_cmp","","",2,null],[11,"lt","","",2,null],[11,"le","","",2,null],[11,"gt","","",2,null],[11,"ge","","",2,null],[11,"cmp","","",2,null],[11,"eq","","",2,null],[11,"ne","","",2,null],[11,"clone","","",2,null],[11,"fmt","","",9,null],[11,"clone","","",9,null],[11,"parse_lazy","","",9,null],[11,"add_error","","",9,null]],"paths":[[3,"Identifier"],[3,"LanguageDef"],[3,"Assoc"],[4,"Fixity"],[3,"Lex"],[3,"WhiteSpace"],[3,"Reserved"],[3,"BetweenChar"],[3,"LanguageEnv"],[3,"Expression"]]};
searchIndex["combine"] = {"doc":"This crate contains parser combinators, roughly based on the Haskell library\n[parsec](http://hackage.haskell.org/package/parsec).","items":[[3,"ParseError","combine","Struct which hold information about an error that occured at a specific position.\nCan hold multiple instances of `Error` if more that one error occured in the same position.",null,null],[12,"position","","The position where the error occured",0,null],[12,"errors","","A vector containing specific information on what errors occured at `position`",0,null],[3,"State","","The `State&lt;I&gt;` struct keeps track of the current position in the stream `I` using the\n`Positioner` trait to update the position.",null,null],[12,"position","","The current position",1,null],[12,"input","","The input stream used when items are requested",1,null],[5,"from_iter","","Converts an `Iterator` into a stream.",null,{"inputs":[{"name":"i"}],"output":{"name":"iteratorstream"}}],[5,"any","","Parses any token",null,{"inputs":[],"output":{"name":"any"}}],[5,"between","","Parses `open` followed by `parser` followed by `close`\nReturns the value of `parser`",null,{"inputs":[{"name":"l"},{"name":"r"},{"name":"p"}],"output":{"name":"between"}}],[5,"chainl1","","Parses `p` 1 or more times separated by `op`\nThe value returned is the one produced by the left associative application of `op`",null,{"inputs":[{"name":"p"},{"name":"op"}],"output":{"name":"chainl1"}}],[5,"chainr1","","Parses `p` one or more times separated by `op`\nThe value returned is the one produced by the right associative application of `op`",null,{"inputs":[{"name":"p"},{"name":"op"}],"output":{"name":"chainr1"}}],[5,"choice","","Takes an array of parsers and tries to apply them each in order.\nFails if all parsers fails or if an applied parser consumes input before failing.",null,{"inputs":[{"name":"s"}],"output":{"name":"choice"}}],[5,"eof","","Succeeds only if the stream is at end of input, fails otherwise.",null,{"inputs":[],"output":{"name":"eof"}}],[5,"env_parser","","Constructs a parser out of an environment and a function which needs the given environment to\ndo the parsing. This is commonly useful to allow multiple parsers to share some environment\nwhile still allowing the parsers to be written in separate functions.",null,null],[5,"many","","Parses `p` zero or more times returning a collection with the values from `p`.\nIf the returned collection cannot be inferred type annotations must be supplied, either by\nannotating the resulting type binding `let collection: Vec&lt;_&gt; = ...` or by specializing when\ncalling many, `many::&lt;Vec&lt;_&gt;, _&gt;(...)`",null,{"inputs":[{"name":"p"}],"output":{"name":"many"}}],[5,"many1","","Parses `p` one or more times returning a collection with the values from `p`.\nIf the returned collection cannot be inferred type annotations must be supplied, either by\nannotating the resulting type binding `let collection: Vec&lt;_&gt; = ...` or by specializing when\ncalling many1 `many1::&lt;Vec&lt;_&gt;, _&gt;(...)`",null,{"inputs":[{"name":"p"}],"output":{"name":"many1"}}],[5,"none_of","","Extract one token and succeeds if it is part of `tokens`.",null,{"inputs":[{"name":"t"}],"output":{"name":"noneof"}}],[5,"one_of","","Extract one token and succeeds if it is part of `tokens`.",null,{"inputs":[{"name":"t"}],"output":{"name":"oneof"}}],[5,"optional","","Returns `Some(value)` and `None` on parse failure (always succeeds)",null,{"inputs":[{"name":"p"}],"output":{"name":"optional"}}],[5,"parser","","Wraps a function, turning it into a parser\nMainly needed to turn closures into parsers as function types can be casted to function pointers\nto make them usable as a parser",null,{"inputs":[{"name":"f"}],"output":{"name":"fnparser"}}],[5,"position","","Parser which just returns the current position in the stream",null,{"inputs":[],"output":{"name":"position"}}],[5,"satisfy","","Parses a token and succeeds depending on the result of `predicate`",null,{"inputs":[{"name":"p"}],"output":{"name":"satisfy"}}],[5,"satisfy_map","","Parses a token and passes it to `predicate`. If `predicate` returns `Some` the parser succeeds\nand returns the value inside the `Option`. If `predicate` returns `None` the parser fails\nwithout consuming any imput.",null,{"inputs":[{"name":"p"}],"output":{"name":"satisfymap"}}],[5,"sep_by","","Parses `parser` zero or more time separated by `separator`, returning a collection with the\nvalues from `p`. If the returned collection cannot be inferred type annotations must be\nsupplied, either by annotating the resulting type binding `let collection: Vec&lt;_&gt; = ...` or by\nspecializing when calling sep_by, `sep_by::&lt;Vec&lt;_&gt;, _, _&gt;(...)`",null,{"inputs":[{"name":"p"},{"name":"s"}],"output":{"name":"sepby"}}],[5,"sep_by1","","Parses `parser` one or more time separated by `separator`, returning a collection with the\nvalues from `p`. If the returned collection cannot be inferred type annotations must be\nsupplied, either by annotating the resulting type binding `let collection: Vec&lt;_&gt; = ...` or by\nspecializing when calling sep_by, `sep_by1::&lt;Vec&lt;_&gt;, _, _&gt;(...)`",null,{"inputs":[{"name":"p"},{"name":"s"}],"output":{"name":"sepby1"}}],[5,"sep_end_by","","Parses `parser` zero or more time separated by `separator`, returning a collection with the\nvalues from `p`. If the returned collection cannot be inferred type annotations must be\nsupplied, either by annotating the resulting type binding `let collection: Vec&lt;_&gt; = ...` or by\nspecializing when calling sep_by, `sep_by::&lt;Vec&lt;_&gt;, _, _&gt;(...)`",null,{"inputs":[{"name":"p"},{"name":"s"}],"output":{"name":"sependby"}}],[5,"sep_end_by1","","Parses `parser` one or more time separated by `separator`, returning a collection with the\nvalues from `p`. If the returned collection cannot be inferred type annotations must be\nsupplied, either by annotating the resulting type binding `let collection: Vec&lt;_&gt; = ...` or by\nspecializing when calling sep_by, `sep_by1::&lt;Vec&lt;_&gt;, _, _&gt;(...)`",null,{"inputs":[{"name":"p"},{"name":"s"}],"output":{"name":"sependby1"}}],[5,"skip_many","","Parses `p` zero or more times ignoring the result",null,{"inputs":[{"name":"p"}],"output":{"name":"skipmany"}}],[5,"skip_many1","","Parses `p` one or more times ignoring the result",null,{"inputs":[{"name":"p"}],"output":{"name":"skipmany1"}}],[5,"token","","Parses a character and succeeds if the character is equal to `c`",null,{"inputs":[{"name":"item"}],"output":{"name":"token"}}],[5,"tokens","","Parses `tokens`.",null,{"inputs":[{"name":"c"},{"name":"info"},{"name":"t"}],"output":{"name":"tokens"}}],[5,"try","","Try acts as `p` except it acts as if the parser hadn&#39;t consumed any input\nif `p` returns an error after consuming input",null,{"inputs":[{"name":"p"}],"output":{"name":"try"}}],[5,"look_ahead","","look_ahead acts as p but doesn&#39;t consume input on success.",null,{"inputs":[{"name":"p"}],"output":{"name":"lookahead"}}],[5,"value","","Always returns the value `v` without consuming any input.",null,{"inputs":[{"name":"t"}],"output":{"name":"value"}}],[5,"unexpected","","Always fails with `message` as an unexpected error.\nNever consumes any input.",null,{"inputs":[{"name":"s"}],"output":{"name":"unexpected"}}],[5,"not_followed_by","","Succeeds only if `parser` fails.\nNever consumes any input.",null,{"inputs":[{"name":"p"}],"output":{"name":"notfollowedby"}}],[0,"primitives","","Module containing the primitive types which is used to create and compose more advanced parsers",null,null],[3,"SourcePosition","combine::primitives","Struct which represents a position in a source file",null,null],[12,"line","","Current line of the input",2,null],[12,"column","","Current column of the input",2,null],[3,"BytePosition","","Struct which represents a position in a byte stream",null,null],[12,"position","","Current position",3,null],[3,"ParseError","","Struct which hold information about an error that occured at a specific position.\nCan hold multiple instances of `Error` if more that one error occured in the same position.",null,null],[12,"position","","The position where the error occured",0,null],[12,"errors","","A vector containing specific information on what errors occured at `position`",0,null],[3,"State","","The `State&lt;I&gt;` struct keeps track of the current position in the stream `I` using the\n`Positioner` trait to update the position.",null,null],[12,"position","","The current position",1,null],[12,"input","","The input stream used when items are requested",1,null],[3,"SliceStream","","Newtype for constructing a stream from a slice where the items in the slice are not copyable",null,null],[12,"0","","",4,null],[3,"IteratorStream","","Wrapper around iterators which allows them to be treated as a stream.\nReturned by `from_iter`.",null,null],[3,"BufferedStream","","A `BufferedStream` wraps an instance `StreamOnce`, allowing it to b used as a `Stream`",null,null],[3,"SharedBufferedStream","","",null,null],[4,"Info","","Enum holding error information\nAs there is implementations of `From` for `T: Positioner`, `String` and `&amp;&#39;static str` the\nconstructor need not be used directly as calling `msg.into()` should turn a message into the\ncorrect `Info` variant",null,null],[13,"Token","","",5,null],[13,"Range","","",5,null],[13,"Owned","","",5,null],[13,"Borrowed","","",5,null],[4,"Error","","Enum used to store information about an error that has occured",null,null],[13,"Unexpected","","Error indicating an unexpected token has been encountered in the stream",6,null],[13,"Expected","","Error indicating that the parser expected something else",6,null],[13,"Message","","Generic message",6,null],[13,"Other","","Variant for containing other types of errors",6,null],[4,"Consumed","","Enum used to indicate if a parser consumed any items of the stream it was given as an input",null,null],[13,"Consumed","","Constructor indicating that the parser has consumed elements",7,null],[13,"Empty","","Constructor indicating that the parser did not consume any elements",7,null],[4,"FastResult","","",null,null],[13,"ConsumedOk","","",8,null],[13,"EmptyOk","","",8,null],[13,"ConsumedErr","","",8,null],[13,"EmptyErr","","",8,null],[5,"uncons","","",null,{"inputs":[{"name":"i"}],"output":{"name":"parseresult"}}],[5,"uncons_while","","Removes items from the input while `predicate` returns `true`.",null,{"inputs":[{"name":"i"},{"name":"f"}],"output":{"name":"consumedresult"}}],[5,"from_iter","","Converts an `Iterator` into a stream.",null,{"inputs":[{"name":"i"}],"output":{"name":"iteratorstream"}}],[6,"ParseResult","","A type alias over the specific `Result` type used by parsers to indicate wether they were\nsuccessful or not.\n`O` is the type that is output on success\n`I` is the specific stream type used in the parser",null,null],[6,"ConsumedResult","","A `Result` type which has the consumed status flattened into the result.\nConversions to and from `std::result::Result` can be done using `result.into()` or\n`From::from(result)`",null,null],[8,"StreamOnce","","`StreamOnce` represents a sequence of items that can be extracted one by one.",null,null],[16,"Item","","The type of items which is yielded from this stream",9,null],[16,"Range","","The type of a range of items yielded from this stream.\nTypes which do not a have a way of yielding ranges of items should just use the\nSelf::Item for this type",9,null],[16,"Position","","Type which represents the position in a stream.\nOrd is required to allow parsers to determine which of two positions are further ahead.",9,null],[10,"uncons","","Takes a stream and removes its first item, yielding the item and the rest of the elements\nReturns `Err` if no element could be retrieved",9,null],[10,"position","","Returns the current position of the stream",9,null],[8,"Stream","","A stream of tokens which can be duplicated",null,null],[8,"RangeStream","","A `RangeStream` is an extension of Stream which allows for zero copy parsing",null,null],[10,"uncons_range","","Takes `size` elements from the stream\nFails if the length of the stream is less than `size`.",10,null],[10,"uncons_while","","Takes items from stream, testing each one with `predicate`\nreturns the range of items which passed `predicate`",10,null],[8,"Range","","",null,null],[10,"len","","Returns the remaining length of `self`.\nThe returned length need not be the same as the number of items left in the stream",11,null],[8,"Positioner","","Trait for updating the position for types which can be yielded from a `Stream`.",null,null],[16,"Position","","The type which keeps track of the position.",12,null],[10,"start","","Creates a start position",12,{"inputs":[],"output":{"name":"position"}}],[10,"update","","Updates the position given that `self` has been taken from the stream",12,null],[8,"Parser","","By implementing the `Parser` trait a type says that it can be used to parse an input stream into\nthe type `Output`.",null,null],[16,"Input","","The type which is take as input for the parser. The type must implement the `Stream` trait\nwhich allows the parser to read item from the type.",13,null],[16,"Output","","The type which is returned if the parser is successful.",13,null],[11,"parse","","Entrypoint of the parser\nTakes some input and tries to parse it returning a `ParseResult`",13,null],[11,"parse_stream","","Parses using the stream `input` by calling Stream::uncons one or more times\nOn success returns `Ok((value, new_state))` on failure it returns `Err(error)`",13,null],[11,"parse_stream_consumed","","Parses using the stream `input` by calling Stream::uncons one or more times\nOn success returns `Ok((value, new_state))` on failure it returns `Err(error)`",13,null],[11,"parse_lazy","","Specialized version of parse_stream where the parser does not need to add an error to the\n`ParseError` when it does not consume any input before encountering the error.\nInstead the error can be added later through the `add_error` method",13,null],[11,"add_error","","Adds the first error that would normally be returned by this parser if it failed",13,null],[11,"by_ref","","Borrows a parser instead of consuming it.",13,null],[11,"with","","Discards the value of the `self` parser and returns the value of `p`\nFails if any of the parsers fails",13,null],[11,"skip","","Discards the value of the `p` parser and returns the value of `self`\nFails if any of the parsers fails",13,null],[11,"and","","Parses with `self` followed by `p`\nSucceeds if both parsers succeed, otherwise fails\nReturns a tuple with both values on success",13,null],[11,"or","","Returns a parser which attempts to parse using `self`. If `self` fails without consuming any\ninput it tries to consume the same input using `p`.",13,null],[11,"then","","Parses using `self` and then passes the value to `f` which returns a parser used to parse\nthe rest of the input",13,null],[11,"map","","Uses `f` to map over the parsed value",13,null],[11,"flat_map","","Uses `f` to map over the output of `self`. If `f` returns an error the parser fails.",13,null],[11,"message","","Parses with `self` and if it fails, adds the message `msg` to the error",13,null],[11,"expected","","Parses with `self` and if it fails without consuming any input any expected errors are\nreplaced by `msg`. `msg` is then used in error messages as &quot;Expected `msg`&quot;.",13,null],[11,"and_then","","Parses with `self` and applies `f` on the result if `self` parses successfully\n`f` may optionally fail with an error which is automatically converted to a `ParseError`",13,null],[11,"iter","","Creates an iterator from a parser and a state. Can be used as an alternative to `many` when\ncollecting directly into a `FromIterator` type is not desirable",13,null],[11,"partial_cmp","","",2,null],[11,"lt","","",2,null],[11,"le","","",2,null],[11,"gt","","",2,null],[11,"ge","","",2,null],[11,"cmp","","",2,null],[11,"eq","","",2,null],[11,"ne","","",2,null],[11,"fmt","","",2,null],[11,"clone","","",2,null],[11,"partial_cmp","","",3,null],[11,"lt","","",3,null],[11,"le","","",3,null],[11,"gt","","",3,null],[11,"ge","","",3,null],[11,"cmp","","",3,null],[11,"eq","","",3,null],[11,"ne","","",3,null],[11,"fmt","","",3,null],[11,"clone","","",3,null],[11,"fmt","","",3,null],[11,"fmt","","",5,null],[11,"clone","","",5,null],[11,"eq","","",5,null],[11,"fmt","","",5,null],[11,"from","","",5,{"inputs":[{"name":"char"}],"output":{"name":"info"}}],[11,"from","","",5,{"inputs":[{"name":"string"}],"output":{"name":"info"}}],[11,"from","","",5,{"inputs":[{"name":"str"}],"output":{"name":"info"}}],[11,"fmt","","",6,null],[11,"eq","","",6,null],[11,"from","","",6,{"inputs":[{"name":"e"}],"output":{"name":"error"}}],[11,"end_of_input","","Returns the `end_of_input` error",6,{"inputs":[],"output":{"name":"error"}}],[11,"fmt_errors","","Formats a slice of errors in a human readable way",6,null],[11,"fmt","","",7,null],[11,"eq","","",7,null],[11,"ne","","",7,null],[11,"clone","","",7,null],[11,"as_mut","","",7,null],[11,"as_ref","","",7,null],[11,"is_empty","","Returns true if `self` is empty",7,null],[11,"into_inner","","Extracts the contained value",7,null],[11,"as_consumed","","Converts `self` into the Consumed state",7,null],[11,"as_empty","","Converts `self` into theEmpty state",7,null],[11,"map","","Maps over the contained value without changing the consumed state",7,null],[11,"merge","","",7,null],[11,"combine","","Combines the Consumed flags from `self` and the result of `f`",7,null],[11,"combine_consumed","","",7,null],[11,"new","","",0,{"inputs":[{"name":"position"},{"name":"error"}],"output":{"name":"parseerror"}}],[11,"empty","","",0,{"inputs":[{"name":"position"}],"output":{"name":"parseerror"}}],[11,"from_errors","","",0,{"inputs":[{"name":"position"},{"name":"vec"}],"output":{"name":"parseerror"}}],[11,"end_of_input","","",0,{"inputs":[{"name":"position"}],"output":{"name":"parseerror"}}],[11,"add_message","","",0,null],[11,"add_error","","",0,null],[11,"set_expected","","",0,null],[11,"merge","","",0,null],[11,"description","","",0,null],[11,"eq","","",0,null],[11,"fmt","","",0,null],[11,"fmt","","",0,null],[11,"fmt","","",2,null],[11,"fmt","","",6,null],[11,"eq","","",1,null],[11,"ne","","",1,null],[11,"clone","","",1,null],[11,"fmt","","",1,null],[11,"new","","Creates a new `State&lt;I&gt;` from an input stream. Initializes the position to\n`Positioner::start()`",1,{"inputs":[{"name":"i"}],"output":{"name":"state"}}],[11,"uncons","","",1,null],[11,"position","","",1,null],[11,"uncons_range","","",1,null],[11,"uncons_while","","",1,null],[11,"fmt","","",4,null],[11,"partial_cmp","","",4,null],[11,"lt","","",4,null],[11,"le","","",4,null],[11,"gt","","",4,null],[11,"ge","","",4,null],[11,"cmp","","",4,null],[11,"eq","","",4,null],[11,"ne","","",4,null],[11,"clone","","",4,null],[11,"uncons","","",4,null],[11,"position","","",4,null],[11,"uncons_range","","",4,null],[11,"uncons_while","","",4,null],[11,"fmt","","",14,null],[11,"clone","","",14,null],[11,"next","","",14,null],[11,"uncons","","",14,null],[11,"position","","",14,null],[11,"start","","",4,{"inputs":[],"output":{"name":"position"}}],[11,"update","","",4,null],[11,"fmt","","",8,null],[11,"eq","","",8,null],[11,"ne","","",8,null],[11,"clone","","",8,null],[11,"as_ref","","",8,null],[11,"and_then","","",8,null],[11,"map","","",15,null],[11,"into","","",8,null],[11,"into","","",15,null],[11,"from","","",15,{"inputs":[{"name":"parseresult"}],"output":{"name":"consumedresult"}}],[11,"fmt","","",16,null],[11,"clone","","",16,null],[11,"as_stream","","",17,null],[11,"new","","Constructs a new `BufferedStream` froma a `StreamOnce` instance with a `lookahead` number\nof elements stored in the buffer.",16,{"inputs":[{"name":"i"},{"name":"usize"}],"output":{"name":"sharedbufferedstream"}}],[11,"uncons","","",16,null],[11,"position","","",16,null],[0,"combinator","combine","Module containing all specific parsers",null,null],[3,"Any","combine::combinator","",null,null],[3,"Satisfy","","",null,null],[3,"SatisfyMap","","",null,null],[3,"Token","","",null,null],[3,"Tokens","","",null,null],[3,"Position","","",null,null],[3,"Choice","","",null,null],[3,"OneOf","","",null,null],[3,"NoneOf","","",null,null],[3,"Count","","",null,null],[3,"Unexpected","","",null,null],[3,"Value","","",null,null],[3,"NotFollowedBy","","",null,null],[3,"Eof","","",null,null],[3,"Iter","","",null,null],[3,"Many","","",null,null],[3,"Many1","","",null,null],[3,"SkipMany","","",null,null],[3,"SkipMany1","","",null,null],[3,"SepBy","","",null,null],[3,"SepBy1","","",null,null],[3,"SepEndBy","","",null,null],[3,"SepEndBy1","","",null,null],[3,"FnParser","","",null,null],[3,"Optional","","",null,null],[3,"Between","","",null,null],[3,"Chainl1","","",null,null],[3,"Chainr1","","",null,null],[3,"Try","","",null,null],[3,"LookAhead","","",null,null],[3,"With","","",null,null],[3,"Skip","","",null,null],[3,"Message","","",null,null],[3,"Or","","",null,null],[3,"Map","","",null,null],[3,"FlatMap","","",null,null],[3,"Then","","",null,null],[3,"Expected","","",null,null],[3,"AndThen","","",null,null],[3,"EnvParser","","",null,null],[5,"any","","Parses any token",null,{"inputs":[],"output":{"name":"any"}}],[5,"satisfy","","Parses a token and succeeds depending on the result of `predicate`",null,{"inputs":[{"name":"p"}],"output":{"name":"satisfy"}}],[5,"satisfy_map","","Parses a token and passes it to `predicate`. If `predicate` returns `Some` the parser succeeds\nand returns the value inside the `Option`. If `predicate` returns `None` the parser fails\nwithout consuming any imput.",null,{"inputs":[{"name":"p"}],"output":{"name":"satisfymap"}}],[5,"token","","Parses a character and succeeds if the character is equal to `c`",null,{"inputs":[{"name":"item"}],"output":{"name":"token"}}],[5,"tokens","","Parses `tokens`.",null,{"inputs":[{"name":"c"},{"name":"info"},{"name":"t"}],"output":{"name":"tokens"}}],[5,"position","","Parser which just returns the current position in the stream",null,{"inputs":[],"output":{"name":"position"}}],[5,"one_of","","Extract one token and succeeds if it is part of `tokens`.",null,{"inputs":[{"name":"t"}],"output":{"name":"oneof"}}],[5,"none_of","","Extract one token and succeeds if it is part of `tokens`.",null,{"inputs":[{"name":"t"}],"output":{"name":"noneof"}}],[5,"count","","Extract one token and succeeds if it is part of `tokens`.",null,{"inputs":[{"name":"usize"},{"name":"p"}],"output":{"name":"count"}}],[5,"choice","","Takes an array of parsers and tries to apply them each in order.\nFails if all parsers fails or if an applied parser consumes input before failing.",null,{"inputs":[{"name":"s"}],"output":{"name":"choice"}}],[5,"unexpected","","Always fails with `message` as an unexpected error.\nNever consumes any input.",null,{"inputs":[{"name":"s"}],"output":{"name":"unexpected"}}],[5,"value","","Always returns the value `v` without consuming any input.",null,{"inputs":[{"name":"t"}],"output":{"name":"value"}}],[5,"not_followed_by","","Succeeds only if `parser` fails.\nNever consumes any input.",null,{"inputs":[{"name":"p"}],"output":{"name":"notfollowedby"}}],[5,"eof","","Succeeds only if the stream is at end of input, fails otherwise.",null,{"inputs":[],"output":{"name":"eof"}}],[5,"many","","Parses `p` zero or more times returning a collection with the values from `p`.\nIf the returned collection cannot be inferred type annotations must be supplied, either by\nannotating the resulting type binding `let collection: Vec&lt;_&gt; = ...` or by specializing when\ncalling many, `many::&lt;Vec&lt;_&gt;, _&gt;(...)`",null,{"inputs":[{"name":"p"}],"output":{"name":"many"}}],[5,"skip_many","","Parses `p` zero or more times ignoring the result",null,{"inputs":[{"name":"p"}],"output":{"name":"skipmany"}}],[5,"skip_many1","","Parses `p` one or more times ignoring the result",null,{"inputs":[{"name":"p"}],"output":{"name":"skipmany1"}}],[5,"many1","","Parses `p` one or more times returning a collection with the values from `p`.\nIf the returned collection cannot be inferred type annotations must be supplied, either by\nannotating the resulting type binding `let collection: Vec&lt;_&gt; = ...` or by specializing when\ncalling many1 `many1::&lt;Vec&lt;_&gt;, _&gt;(...)`",null,{"inputs":[{"name":"p"}],"output":{"name":"many1"}}],[5,"sep_by","","Parses `parser` zero or more time separated by `separator`, returning a collection with the\nvalues from `p`. If the returned collection cannot be inferred type annotations must be\nsupplied, either by annotating the resulting type binding `let collection: Vec&lt;_&gt; = ...` or by\nspecializing when calling sep_by, `sep_by::&lt;Vec&lt;_&gt;, _, _&gt;(...)`",null,{"inputs":[{"name":"p"},{"name":"s"}],"output":{"name":"sepby"}}],[5,"sep_by1","","Parses `parser` one or more time separated by `separator`, returning a collection with the\nvalues from `p`. If the returned collection cannot be inferred type annotations must be\nsupplied, either by annotating the resulting type binding `let collection: Vec&lt;_&gt; = ...` or by\nspecializing when calling sep_by, `sep_by1::&lt;Vec&lt;_&gt;, _, _&gt;(...)`",null,{"inputs":[{"name":"p"},{"name":"s"}],"output":{"name":"sepby1"}}],[5,"sep_end_by","","Parses `parser` zero or more time separated by `separator`, returning a collection with the\nvalues from `p`. If the returned collection cannot be inferred type annotations must be\nsupplied, either by annotating the resulting type binding `let collection: Vec&lt;_&gt; = ...` or by\nspecializing when calling sep_by, `sep_by::&lt;Vec&lt;_&gt;, _, _&gt;(...)`",null,{"inputs":[{"name":"p"},{"name":"s"}],"output":{"name":"sependby"}}],[5,"sep_end_by1","","Parses `parser` one or more time separated by `separator`, returning a collection with the\nvalues from `p`. If the returned collection cannot be inferred type annotations must be\nsupplied, either by annotating the resulting type binding `let collection: Vec&lt;_&gt; = ...` or by\nspecializing when calling sep_by, `sep_by1::&lt;Vec&lt;_&gt;, _, _&gt;(...)`",null,{"inputs":[{"name":"p"},{"name":"s"}],"output":{"name":"sependby1"}}],[5,"parser","","Wraps a function, turning it into a parser\nMainly needed to turn closures into parsers as function types can be casted to function pointers\nto make them usable as a parser",null,{"inputs":[{"name":"f"}],"output":{"name":"fnparser"}}],[5,"optional","","Returns `Some(value)` and `None` on parse failure (always succeeds)",null,{"inputs":[{"name":"p"}],"output":{"name":"optional"}}],[5,"between","","Parses `open` followed by `parser` followed by `close`\nReturns the value of `parser`",null,{"inputs":[{"name":"l"},{"name":"r"},{"name":"p"}],"output":{"name":"between"}}],[5,"chainl1","","Parses `p` 1 or more times separated by `op`\nThe value returned is the one produced by the left associative application of `op`",null,{"inputs":[{"name":"p"},{"name":"op"}],"output":{"name":"chainl1"}}],[5,"chainr1","","Parses `p` one or more times separated by `op`\nThe value returned is the one produced by the right associative application of `op`",null,{"inputs":[{"name":"p"},{"name":"op"}],"output":{"name":"chainr1"}}],[5,"try","","Try acts as `p` except it acts as if the parser hadn&#39;t consumed any input\nif `p` returns an error after consuming input",null,{"inputs":[{"name":"p"}],"output":{"name":"try"}}],[5,"look_ahead","","look_ahead acts as p but doesn&#39;t consume input on success.",null,{"inputs":[{"name":"p"}],"output":{"name":"lookahead"}}],[5,"with","","",null,{"inputs":[{"name":"p1"},{"name":"p2"}],"output":{"name":"with"}}],[5,"skip","","",null,{"inputs":[{"name":"p1"},{"name":"p2"}],"output":{"name":"skip"}}],[5,"message","","",null,{"inputs":[{"name":"p"},{"name":"info"}],"output":{"name":"message"}}],[5,"or","","",null,{"inputs":[{"name":"p1"},{"name":"p2"}],"output":{"name":"or"}}],[5,"map","","",null,{"inputs":[{"name":"p"},{"name":"f"}],"output":{"name":"map"}}],[5,"flat_map","","",null,{"inputs":[{"name":"p"},{"name":"f"}],"output":{"name":"flatmap"}}],[5,"then","","",null,{"inputs":[{"name":"p"},{"name":"f"}],"output":{"name":"then"}}],[5,"expected","","",null,{"inputs":[{"name":"p"},{"name":"info"}],"output":{"name":"expected"}}],[5,"and_then","","",null,{"inputs":[{"name":"p"},{"name":"f"}],"output":{"name":"andthen"}}],[5,"env_parser","","Constructs a parser out of an environment and a function which needs the given environment to\ndo the parsing. This is commonly useful to allow multiple parsers to share some environment\nwhile still allowing the parsers to be written in separate functions.",null,null],[11,"clone","","",18,null],[11,"parse_lazy","","",18,null],[11,"clone","","",19,null],[11,"parse_lazy","","",19,null],[11,"clone","","",20,null],[11,"parse_lazy","","",20,null],[11,"clone","","",21,null],[11,"parse_lazy","","",21,null],[11,"add_error","","",21,null],[11,"clone","","",22,null],[11,"parse_lazy","","",22,null],[11,"add_error","","",22,null],[11,"clone","","",23,null],[11,"parse_lazy","","",23,null],[11,"clone","","",24,null],[11,"parse_lazy","","",24,null],[11,"add_error","","",24,null],[11,"clone","","",25,null],[11,"parse_lazy","","",25,null],[11,"add_error","","",25,null],[11,"clone","","",26,null],[11,"parse_lazy","","",26,null],[11,"clone","","",27,null],[11,"parse_lazy","","",27,null],[11,"add_error","","",27,null],[11,"clone","","",28,null],[11,"parse_lazy","","",28,null],[11,"add_error","","",28,null],[11,"clone","","",29,null],[11,"parse_lazy","","",29,null],[11,"clone","","",30,null],[11,"parse_stream","","",30,null],[11,"parse_stream_consumed","","",30,null],[11,"parse_lazy","","",30,null],[11,"add_error","","",30,null],[11,"clone","","",31,null],[11,"parse_lazy","","",31,null],[11,"add_error","","",31,null],[11,"new","","",32,{"inputs":[{"name":"p"},{"name":"input"}],"output":{"name":"iter"}}],[11,"into_result","","Converts the iterator to a `ParseResult`, returning `Ok` if the parsing so far has be done\nwithout any errors which consumed data.",32,null],[11,"next","","",32,null],[11,"clone","","",33,null],[11,"parse_stream_consumed","","",33,null],[11,"clone","","",34,null],[11,"parse_lazy","","",34,null],[11,"add_error","","",34,null],[11,"clone","","",35,null],[11,"parse_stream","","",35,null],[11,"parse_stream_consumed","","",35,null],[11,"parse_lazy","","",35,null],[11,"add_error","","",35,null],[11,"clone","","",36,null],[11,"parse_stream","","",36,null],[11,"parse_stream_consumed","","",36,null],[11,"parse_lazy","","",36,null],[11,"add_error","","",36,null],[11,"clone","","",37,null],[11,"parse_lazy","","",37,null],[11,"add_error","","",37,null],[11,"clone","","",38,null],[11,"parse_lazy","","",38,null],[11,"add_error","","",38,null],[11,"clone","","",39,null],[11,"parse_lazy","","",39,null],[11,"add_error","","",39,null],[11,"clone","","",40,null],[11,"parse_lazy","","",40,null],[11,"add_error","","",40,null],[11,"clone","","",41,null],[11,"parse_stream","","",41,null],[11,"clone","","",42,null],[11,"parse_lazy","","",42,null],[11,"clone","","",43,null],[11,"parse_stream","","",43,null],[11,"parse_stream_consumed","","",43,null],[11,"parse_lazy","","",43,null],[11,"add_error","","",43,null],[11,"clone","","",44,null],[11,"parse_lazy","","",44,null],[11,"add_error","","",44,null],[11,"clone","","",45,null],[11,"parse_lazy","","",45,null],[11,"add_error","","",45,null],[11,"clone","","",46,null],[11,"parse_lazy","","",46,null],[11,"add_error","","",46,null],[11,"clone","","",47,null],[11,"parse_lazy","","",47,null],[11,"add_error","","",47,null],[11,"clone","","",48,null],[11,"parse_lazy","","",48,null],[11,"add_error","","",48,null],[11,"clone","","",49,null],[11,"parse_lazy","","",49,null],[11,"add_error","","",49,null],[11,"clone","","",50,null],[11,"parse_stream","","",50,null],[11,"parse_lazy","","",50,null],[11,"add_error","","",50,null],[11,"clone","","",51,null],[11,"parse_lazy","","",51,null],[11,"add_error","","",51,null],[11,"clone","","",52,null],[11,"parse_lazy","","",52,null],[11,"add_error","","",52,null],[11,"clone","","",53,null],[11,"parse_lazy","","",53,null],[11,"add_error","","",53,null],[11,"clone","","",54,null],[11,"parse_lazy","","",54,null],[11,"add_error","","",54,null],[11,"clone","","",55,null],[11,"parse_stream","","",55,null],[11,"parse_lazy","","",55,null],[11,"add_error","","",55,null],[11,"clone","","",56,null],[11,"parse_lazy","","",56,null],[11,"add_error","","",56,null],[11,"clone","","",57,null],[11,"parse_lazy","","",57,null],[0,"range","combine","Module containing zero-copy parsers",null,null],[3,"Range","combine::range","",null,null],[3,"Take","","",null,null],[3,"TakeWhile","","",null,null],[3,"TakeWhile1","","",null,null],[5,"range","","```\n# extern crate combine;\n# use combine::range::range;\n# use combine::*;\n# fn main() {\nlet mut parser = range(&quot;hello&quot;);\nlet result = parser.parse(&quot;hello world&quot;);\nassert_eq!(result, Ok((&quot;hello&quot;, &quot; world&quot;)));\nlet result = parser.parse(&quot;hel world&quot;);\nassert!(result.is_err());\n# }\n```",null,{"inputs":[{"name":"range"}],"output":{"name":"range"}}],[5,"take","","```\n# extern crate combine;\n# use combine::range::take;\n# use combine::*;\n# fn main() {\nlet mut parser = take(1);\nlet result = parser.parse(&quot;1&quot;);\nassert_eq!(result, Ok((&quot;1&quot;, &quot;&quot;)));\nlet mut parser = take(4);\nlet result = parser.parse(&quot;123abc&quot;);\nassert_eq!(result, Ok((&quot;123a&quot;, &quot;bc&quot;)));\nlet result = parser.parse(&quot;abc&quot;);\nassert!(result.is_err());\n# }\n```",null,{"inputs":[{"name":"usize"}],"output":{"name":"take"}}],[5,"take_while","","```\n# extern crate combine;\n# use combine::range::take_while;\n# use combine::*;\n# fn main() {\nlet mut parser = take_while(|c: char| c.is_digit(10));\nlet result = parser.parse(&quot;123abc&quot;);\nassert_eq!(result, Ok((&quot;123&quot;, &quot;abc&quot;)));\nlet result = parser.parse(&quot;abc&quot;);\nassert_eq!(result, Ok((&quot;&quot;, &quot;abc&quot;)));\n# }\n```",null,{"inputs":[{"name":"f"}],"output":{"name":"takewhile"}}],[5,"take_while1","","```\n# extern crate combine;\n# use combine::range::take_while1;\n# use combine::*;\n# fn main() {\nlet mut parser = take_while1(|c: char| c.is_digit(10));\nlet result = parser.parse(&quot;123abc&quot;);\nassert_eq!(result, Ok((&quot;123&quot;, &quot;abc&quot;)));\nlet result = parser.parse(&quot;abc&quot;);\nassert!(result.is_err());\n# }\n```",null,{"inputs":[{"name":"f"}],"output":{"name":"takewhile1"}}],[11,"parse_lazy","","",58,null],[11,"add_error","","",58,null],[11,"parse_lazy","","",59,null],[11,"parse_lazy","","",60,null],[11,"parse_lazy","","",61,null],[0,"byte","combine","Module containing parsers specialized on byte streams",null,null],[3,"Digit","combine::byte","",null,null],[3,"Space","","",null,null],[3,"Spaces","","",null,null],[3,"Newline","","",null,null],[3,"CrLf","","",null,null],[3,"Tab","","",null,null],[3,"Upper","","",null,null],[3,"Lower","","",null,null],[3,"AlphaNum","","",null,null],[3,"Letter","","",null,null],[3,"HexDigit","","",null,null],[3,"Bytes","","",null,null],[3,"BytesCmp","","",null,null],[5,"byte","","Parses a character and succeeds if the character is equal to `c`",null,{"inputs":[{"name":"u8"}],"output":{"name":"token"}}],[5,"digit","","Parses a digit from a stream containing characters",null,{"inputs":[],"output":{"name":"digit"}}],[5,"space","","Parses whitespace",null,{"inputs":[],"output":{"name":"space"}}],[5,"spaces","","Skips over zero or more spaces",null,{"inputs":[],"output":{"name":"spaces"}}],[5,"newline","","Parses a newline character",null,{"inputs":[],"output":{"name":"newline"}}],[5,"crlf","","Parses carriage return and newline, returning the newline character.",null,{"inputs":[],"output":{"name":"crlf"}}],[5,"tab","","Parses a tab character",null,{"inputs":[],"output":{"name":"tab"}}],[5,"upper","","Parses an uppercase letter",null,{"inputs":[],"output":{"name":"upper"}}],[5,"lower","","Parses an lowercase letter",null,{"inputs":[],"output":{"name":"lower"}}],[5,"alpha_num","","Parses either an alphabet letter or digit",null,{"inputs":[],"output":{"name":"alphanum"}}],[5,"letter","","Parses an alphabet letter",null,{"inputs":[],"output":{"name":"letter"}}],[5,"hex_digit","","Parses a hexdecimal digit with uppercase and lowercase",null,{"inputs":[],"output":{"name":"hexdigit"}}],[5,"bytes","","Parses the bytes `s`. If you have a stream implementing `RangeStream` such as `&amp;[u8]` you can\nalso use the `range` parser which may be more efficient.",null,null],[5,"bytes_cmp","","Parses the bytes `s` using `cmp` to compare each token. If you have a stream implementing\n`RangeStream` such as `&amp;[u8]` you can also use the `range` parser which may be more efficient.",null,null],[11,"clone","","",62,null],[11,"parse_lazy","","",62,null],[11,"add_error","","",62,null],[11,"clone","","",63,null],[11,"parse_lazy","","",63,null],[11,"add_error","","",63,null],[11,"clone","","",64,null],[11,"parse_lazy","","",64,null],[11,"add_error","","",64,null],[11,"clone","","",65,null],[11,"parse_lazy","","",65,null],[11,"add_error","","",65,null],[11,"clone","","",66,null],[11,"parse_lazy","","",66,null],[11,"add_error","","",66,null],[11,"clone","","",67,null],[11,"parse_lazy","","",67,null],[11,"add_error","","",67,null],[11,"clone","","",68,null],[11,"parse_lazy","","",68,null],[11,"add_error","","",68,null],[11,"clone","","",69,null],[11,"parse_lazy","","",69,null],[11,"add_error","","",69,null],[11,"clone","","",70,null],[11,"parse_lazy","","",70,null],[11,"add_error","","",70,null],[11,"clone","","",71,null],[11,"parse_lazy","","",71,null],[11,"add_error","","",71,null],[11,"clone","","",72,null],[11,"parse_lazy","","",72,null],[11,"add_error","","",72,null],[11,"clone","","",73,null],[11,"parse_lazy","","",73,null],[11,"add_error","","",73,null],[11,"clone","","",74,null],[11,"parse_lazy","","",74,null],[11,"add_error","","",74,null],[0,"char","combine","Module containing parsers specialized on character streams",null,null],[3,"Digit","combine::char","",null,null],[3,"Space","","",null,null],[3,"Spaces","","",null,null],[3,"Newline","","",null,null],[3,"CrLf","","",null,null],[3,"Tab","","",null,null],[3,"Upper","","",null,null],[3,"Lower","","",null,null],[3,"AlphaNum","","",null,null],[3,"Letter","","",null,null],[3,"OctDigit","","",null,null],[3,"HexDigit","","",null,null],[3,"Str","","",null,null],[3,"StrCmp","","",null,null],[5,"char","","Parses a character and succeeds if the character is equal to `c`",null,{"inputs":[{"name":"char"}],"output":{"name":"token"}}],[5,"digit","","Parses a digit from a stream containing characters",null,{"inputs":[],"output":{"name":"digit"}}],[5,"space","","Parses whitespace",null,{"inputs":[],"output":{"name":"space"}}],[5,"spaces","","Skips over zero or more spaces",null,{"inputs":[],"output":{"name":"spaces"}}],[5,"newline","","Parses a newline character",null,{"inputs":[],"output":{"name":"newline"}}],[5,"crlf","","Parses carriage return and newline, returning the newline character.",null,{"inputs":[],"output":{"name":"crlf"}}],[5,"tab","","Parses a tab character",null,{"inputs":[],"output":{"name":"tab"}}],[5,"upper","","Parses an uppercase letter",null,{"inputs":[],"output":{"name":"upper"}}],[5,"lower","","Parses an lowercase letter",null,{"inputs":[],"output":{"name":"lower"}}],[5,"alpha_num","","Parses either an alphabet letter or digit",null,{"inputs":[],"output":{"name":"alphanum"}}],[5,"letter","","Parses an alphabet letter",null,{"inputs":[],"output":{"name":"letter"}}],[5,"oct_digit","","Parses an octal digit",null,{"inputs":[],"output":{"name":"octdigit"}}],[5,"hex_digit","","Parses a hexdecimal digit with uppercase and lowercase",null,{"inputs":[],"output":{"name":"hexdigit"}}],[5,"string","","Parses the string `s`",null,{"inputs":[{"name":"str"}],"output":{"name":"str"}}],[5,"string_cmp","","Parses the string `s`, using `cmp` to compare each character",null,{"inputs":[{"name":"str"},{"name":"c"}],"output":{"name":"strcmp"}}],[11,"clone","","",75,null],[11,"parse_lazy","","",75,null],[11,"add_error","","",75,null],[11,"clone","","",76,null],[11,"parse_lazy","","",76,null],[11,"add_error","","",76,null],[11,"clone","","",77,null],[11,"parse_lazy","","",77,null],[11,"add_error","","",77,null],[11,"clone","","",78,null],[11,"parse_lazy","","",78,null],[11,"add_error","","",78,null],[11,"clone","","",79,null],[11,"parse_lazy","","",79,null],[11,"add_error","","",79,null],[11,"clone","","",80,null],[11,"parse_lazy","","",80,null],[11,"add_error","","",80,null],[11,"clone","","",81,null],[11,"parse_lazy","","",81,null],[11,"add_error","","",81,null],[11,"clone","","",82,null],[11,"parse_lazy","","",82,null],[11,"add_error","","",82,null],[11,"clone","","",83,null],[11,"parse_lazy","","",83,null],[11,"add_error","","",83,null],[11,"clone","","",84,null],[11,"parse_lazy","","",84,null],[11,"add_error","","",84,null],[11,"clone","","",85,null],[11,"parse_lazy","","",85,null],[11,"add_error","","",85,null],[11,"clone","","",86,null],[11,"parse_lazy","","",86,null],[11,"add_error","","",86,null],[11,"clone","","",87,null],[11,"parse_lazy","","",87,null],[11,"add_error","","",87,null],[11,"clone","","",88,null],[11,"parse_lazy","","",88,null],[11,"add_error","","",88,null],[6,"ConsumedResult","combine","A `Result` type which has the consumed status flattened into the result.\nConversions to and from `std::result::Result` can be done using `result.into()` or\n`From::from(result)`",null,null],[6,"ParseResult","","A type alias over the specific `Result` type used by parsers to indicate wether they were\nsuccessful or not.\n`O` is the type that is output on success\n`I` is the specific stream type used in the parser",null,null],[8,"Parser","","By implementing the `Parser` trait a type says that it can be used to parse an input stream into\nthe type `Output`.",null,null],[16,"Input","","The type which is take as input for the parser. The type must implement the `Stream` trait\nwhich allows the parser to read item from the type.",13,null],[16,"Output","","The type which is returned if the parser is successful.",13,null],[11,"parse","","Entrypoint of the parser\nTakes some input and tries to parse it returning a `ParseResult`",13,null],[11,"parse_stream","","Parses using the stream `input` by calling Stream::uncons one or more times\nOn success returns `Ok((value, new_state))` on failure it returns `Err(error)`",13,null],[11,"parse_stream_consumed","","Parses using the stream `input` by calling Stream::uncons one or more times\nOn success returns `Ok((value, new_state))` on failure it returns `Err(error)`",13,null],[11,"parse_lazy","","Specialized version of parse_stream where the parser does not need to add an error to the\n`ParseError` when it does not consume any input before encountering the error.\nInstead the error can be added later through the `add_error` method",13,null],[11,"add_error","","Adds the first error that would normally be returned by this parser if it failed",13,null],[11,"by_ref","","Borrows a parser instead of consuming it.",13,null],[11,"with","","Discards the value of the `self` parser and returns the value of `p`\nFails if any of the parsers fails",13,null],[11,"skip","","Discards the value of the `p` parser and returns the value of `self`\nFails if any of the parsers fails",13,null],[11,"and","","Parses with `self` followed by `p`\nSucceeds if both parsers succeed, otherwise fails\nReturns a tuple with both values on success",13,null],[11,"or","","Returns a parser which attempts to parse using `self`. If `self` fails without consuming any\ninput it tries to consume the same input using `p`.",13,null],[11,"then","","Parses using `self` and then passes the value to `f` which returns a parser used to parse\nthe rest of the input",13,null],[11,"map","","Uses `f` to map over the parsed value",13,null],[11,"flat_map","","Uses `f` to map over the output of `self`. If `f` returns an error the parser fails.",13,null],[11,"message","","Parses with `self` and if it fails, adds the message `msg` to the error",13,null],[11,"expected","","Parses with `self` and if it fails without consuming any input any expected errors are\nreplaced by `msg`. `msg` is then used in error messages as &quot;Expected `msg`&quot;.",13,null],[11,"and_then","","Parses with `self` and applies `f` on the result if `self` parses successfully\n`f` may optionally fail with an error which is automatically converted to a `ParseError`",13,null],[11,"iter","","Creates an iterator from a parser and a state. Can be used as an alternative to `many` when\ncollecting directly into a `FromIterator` type is not desirable",13,null],[8,"Stream","","A stream of tokens which can be duplicated",null,null],[8,"StreamOnce","","`StreamOnce` represents a sequence of items that can be extracted one by one.",null,null],[16,"Item","","The type of items which is yielded from this stream",9,null],[16,"Range","","The type of a range of items yielded from this stream.\nTypes which do not a have a way of yielding ranges of items should just use the\nSelf::Item for this type",9,null],[16,"Position","","Type which represents the position in a stream.\nOrd is required to allow parsers to determine which of two positions are further ahead.",9,null],[10,"uncons","","Takes a stream and removes its first item, yielding the item and the rest of the elements\nReturns `Err` if no element could be retrieved",9,null],[10,"position","","Returns the current position of the stream",9,null],[14,"ctry!","","",null,null]],"paths":[[3,"ParseError"],[3,"State"],[3,"SourcePosition"],[3,"BytePosition"],[3,"SliceStream"],[4,"Info"],[4,"Error"],[4,"Consumed"],[4,"FastResult"],[8,"StreamOnce"],[8,"RangeStream"],[8,"Range"],[8,"Positioner"],[8,"Parser"],[3,"IteratorStream"],[6,"ConsumedResult"],[3,"BufferedStream"],[3,"SharedBufferedStream"],[3,"Any"],[3,"Satisfy"],[3,"SatisfyMap"],[3,"Token"],[3,"Tokens"],[3,"Position"],[3,"Choice"],[3,"OneOf"],[3,"NoneOf"],[3,"Count"],[3,"Unexpected"],[3,"Value"],[3,"NotFollowedBy"],[3,"Eof"],[3,"Iter"],[3,"Many"],[3,"Many1"],[3,"SkipMany"],[3,"SkipMany1"],[3,"SepBy"],[3,"SepBy1"],[3,"SepEndBy"],[3,"SepEndBy1"],[3,"FnParser"],[3,"Optional"],[3,"Between"],[3,"Chainl1"],[3,"Chainr1"],[3,"Try"],[3,"LookAhead"],[3,"With"],[3,"Skip"],[3,"Message"],[3,"Or"],[3,"Map"],[3,"FlatMap"],[3,"Then"],[3,"Expected"],[3,"AndThen"],[3,"EnvParser"],[3,"Range"],[3,"Take"],[3,"TakeWhile"],[3,"TakeWhile1"],[3,"Digit"],[3,"Space"],[3,"Spaces"],[3,"Newline"],[3,"CrLf"],[3,"Tab"],[3,"Upper"],[3,"Lower"],[3,"AlphaNum"],[3,"Letter"],[3,"HexDigit"],[3,"Bytes"],[3,"BytesCmp"],[3,"Digit"],[3,"Space"],[3,"Spaces"],[3,"Newline"],[3,"CrLf"],[3,"Tab"],[3,"Upper"],[3,"Lower"],[3,"AlphaNum"],[3,"Letter"],[3,"OctDigit"],[3,"HexDigit"],[3,"Str"],[3,"StrCmp"]]};
searchIndex["ascii"] = {"doc":"A library that provides ASCII-only string and character types, equivalent to the `char`, `str` and\n`String` types in the standard library.","items":[[3,"ToAsciiCharError","ascii","Error returned by `ToAsciiChar`.",null,null],[3,"AsciiStr","","AsciiStr represents a byte or string slice that only contains ASCII characters.",null,null],[3,"AsAsciiStrError","","Error that is returned when a sequence of `u8` are not all ASCII.",null,null],[3,"AsciiString","","A growable string stored as an ASCII encoded buffer.",null,null],[4,"AsciiChar","","An ASCII character. It wraps a `u8`, with the highest bit always zero.",null,null],[13,"Null","","`&#39;\\0&#39;`",0,null],[13,"SOH","","[Start Of Heading](http://en.wikipedia.org/wiki/Start_of_Heading)",0,null],[13,"SOX","","[Start Of teXt](http://en.wikipedia.org/wiki/Start_of_Text)",0,null],[13,"ETX","","[End of TeXt](http://en.wikipedia.org/wiki/End-of-Text_character)",0,null],[13,"EOT","","[End Of Transmission](http://en.wikipedia.org/wiki/End-of-Transmission_character)",0,null],[13,"ENQ","","[Enquiry](http://en.wikipedia.org/wiki/Enquiry_character)",0,null],[13,"ACK","","[Acknowledgement](http://en.wikipedia.org/wiki/Acknowledge_character)",0,null],[13,"Bell","","[bell / alarm / audible](http://en.wikipedia.org/wiki/Bell_character)",0,null],[13,"BackSpace","","[Backspace](http://en.wikipedia.org/wiki/Backspace)",0,null],[13,"Tab","","`&#39;\\t&#39;`",0,null],[13,"LineFeed","","`&#39;\\n&#39;`",0,null],[13,"VT","","[Vertical tab](http://en.wikipedia.org/wiki/Vertical_Tab)",0,null],[13,"FF","","[Form Feed](http://en.wikipedia.org/wiki/Form_Feed)",0,null],[13,"CarriageReturn","","`&#39;\\r&#39;`",0,null],[13,"SI","","[Shift In](http://en.wikipedia.org/wiki/Shift_Out_and_Shift_In_characters)",0,null],[13,"SO","","[Shift Out](http://en.wikipedia.org/wiki/Shift_Out_and_Shift_In_characters)",0,null],[13,"DLE","","[Data Link Escape](http://en.wikipedia.org/wiki/Data_Link_Escape)",0,null],[13,"DC1","","[Device control 1, often XON](http://en.wikipedia.org/wiki/Device_Control_1)",0,null],[13,"DC2","","Device control 2",0,null],[13,"DC3","","Device control 3, Often XOFF",0,null],[13,"DC4","","Device control 4",0,null],[13,"NAK","","[Negative AcKnowledgement](http://en.wikipedia.org/wiki/Negative-acknowledge_character)",0,null],[13,"SYN","","[Synchronous idle](http://en.wikipedia.org/wiki/Synchronous_Idle)",0,null],[13,"ETB","","[End of Transmission Block](http://en.wikipedia.org/wiki/End-of-Transmission-Block_character)",0,null],[13,"CAN","","[Cancel](http://en.wikipedia.org/wiki/Cancel_character)",0,null],[13,"EM","","[End of Medium](http://en.wikipedia.org/wiki/End_of_Medium)",0,null],[13,"SUB","","[Substitute](http://en.wikipedia.org/wiki/Substitute_character)",0,null],[13,"ESC","","[Escape](http://en.wikipedia.org/wiki/Escape_character)",0,null],[13,"FS","","[File Separator](http://en.wikipedia.org/wiki/File_separator)",0,null],[13,"GS","","[Group Separator](http://en.wikipedia.org/wiki/Group_separator)",0,null],[13,"RS","","[Record Separator](http://en.wikipedia.org/wiki/Record_separator)",0,null],[13,"US","","[Unit Separator](http://en.wikipedia.org/wiki/Unit_separator)",0,null],[13,"Space","","`&#39; &#39;`",0,null],[13,"Exclamation","","`&#39;!&#39;`",0,null],[13,"Quotation","","`&#39;&quot;&#39;`",0,null],[13,"Hash","","`&#39;#&#39;`",0,null],[13,"Dollar","","`&#39;$&#39;`",0,null],[13,"Percent","","`&#39;%&#39;`",0,null],[13,"Ampersand","","`&#39;&amp;&#39;`",0,null],[13,"Apostrophe","","`&#39;\\&#39;&#39;`",0,null],[13,"ParenOpen","","`&#39;(&#39;`",0,null],[13,"ParenClose","","`&#39;)&#39;`",0,null],[13,"Asterisk","","`&#39;*&#39;`",0,null],[13,"Plus","","`&#39;+&#39;`",0,null],[13,"Comma","","`&#39;,&#39;`",0,null],[13,"Minus","","`&#39;-&#39;`",0,null],[13,"Dot","","`&#39;.&#39;`",0,null],[13,"Slash","","`&#39;/&#39;`",0,null],[13,"_0","","`&#39;0&#39;`",0,null],[13,"_1","","`&#39;1&#39;`",0,null],[13,"_2","","`&#39;2&#39;`",0,null],[13,"_3","","`&#39;3&#39;`",0,null],[13,"_4","","`&#39;4&#39;`",0,null],[13,"_5","","`&#39;5&#39;`",0,null],[13,"_6","","`&#39;6&#39;`",0,null],[13,"_7","","`&#39;7&#39;`",0,null],[13,"_8","","`&#39;8&#39;`",0,null],[13,"_9","","`&#39;9&#39;`",0,null],[13,"Colon","","`&#39;:&#39;`",0,null],[13,"Semicolon","","`&#39;;&#39;`",0,null],[13,"LessThan","","`&#39;&lt;&#39;`",0,null],[13,"Equal","","`&#39;=&#39;`",0,null],[13,"GreaterThan","","`&#39;&gt;&#39;`",0,null],[13,"Question","","`&#39;?&#39;`",0,null],[13,"At","","`&#39;@&#39;`",0,null],[13,"A","","`&#39;A&#39;`",0,null],[13,"B","","`&#39;B&#39;`",0,null],[13,"C","","`&#39;C&#39;`",0,null],[13,"D","","`&#39;D&#39;`",0,null],[13,"E","","`&#39;E&#39;`",0,null],[13,"F","","`&#39;F&#39;`",0,null],[13,"G","","`&#39;G&#39;`",0,null],[13,"H","","`&#39;H&#39;`",0,null],[13,"I","","`&#39;I&#39;`",0,null],[13,"J","","`&#39;J&#39;`",0,null],[13,"K","","`&#39;K&#39;`",0,null],[13,"L","","`&#39;L&#39;`",0,null],[13,"M","","`&#39;M&#39;`",0,null],[13,"N","","`&#39;N&#39;`",0,null],[13,"O","","`&#39;O&#39;`",0,null],[13,"P","","`&#39;P&#39;`",0,null],[13,"Q","","`&#39;Q&#39;`",0,null],[13,"R","","`&#39;R&#39;`",0,null],[13,"S","","`&#39;S&#39;`",0,null],[13,"T","","`&#39;T&#39;`",0,null],[13,"U","","`&#39;U&#39;`",0,null],[13,"V","","`&#39;V&#39;`",0,null],[13,"W","","`&#39;W&#39;`",0,null],[13,"X","","`&#39;X&#39;`",0,null],[13,"Y","","`&#39;Y&#39;`",0,null],[13,"Z","","`&#39;Z&#39;`",0,null],[13,"BracketOpen","","`&#39;[&#39;`",0,null],[13,"BackSlash","","`&#39;\\&#39;`",0,null],[13,"BracketClose","","`&#39;]&#39;`",0,null],[13,"Caret","","`&#39;_&#39;`",0,null],[13,"UnderScore","","`&#39;_&#39;`",0,null],[13,"Grave","","`&#39;`&#39;`",0,null],[13,"a","","`&#39;a&#39;`",0,null],[13,"b","","`&#39;b&#39;`",0,null],[13,"c","","`&#39;c&#39;`",0,null],[13,"d","","`&#39;d&#39;`",0,null],[13,"e","","`&#39;e&#39;`",0,null],[13,"f","","`&#39;f&#39;`",0,null],[13,"g","","`&#39;g&#39;`",0,null],[13,"h","","`&#39;h&#39;`",0,null],[13,"i","","`&#39;i&#39;`",0,null],[13,"j","","`&#39;j&#39;`",0,null],[13,"k","","`&#39;k&#39;`",0,null],[13,"l","","`&#39;l&#39;`",0,null],[13,"m","","`&#39;m&#39;`",0,null],[13,"n","","`&#39;n&#39;`",0,null],[13,"o","","`&#39;o&#39;`",0,null],[13,"p","","`&#39;p&#39;`",0,null],[13,"q","","`&#39;q&#39;`",0,null],[13,"r","","`&#39;r&#39;`",0,null],[13,"s","","`&#39;s&#39;`",0,null],[13,"t","","`&#39;t&#39;`",0,null],[13,"u","","`&#39;u&#39;`",0,null],[13,"v","","`&#39;v&#39;`",0,null],[13,"w","","`&#39;w&#39;`",0,null],[13,"x","","`&#39;x&#39;`",0,null],[13,"y","","`&#39;y&#39;`",0,null],[13,"z","","`&#39;z&#39;`",0,null],[13,"CurlyBraceOpen","","`&#39;{&#39;`",0,null],[13,"VerticalBar","","`&#39;|&#39;`",0,null],[13,"CurlyBraceClose","","`&#39;}&#39;`",0,null],[13,"Tilde","","`&#39;~&#39;`",0,null],[13,"DEL","","[Delete](http://en.wikipedia.org/wiki/Delete_character)",0,null],[11,"hash","","",0,null],[11,"cmp","","",0,null],[11,"partial_cmp","","",0,null],[11,"eq","","",0,null],[11,"clone","","",0,null],[11,"from","","Constructs an ASCII character from a `u8`, `char` or other character type.",0,{"inputs":[{"name":"c"}],"output":{"name":"result"}}],[11,"from_unchecked","","Constructs an ASCII character from a `char` or `u8` without any checks.",0,{"inputs":[{"name":"c"}],"output":{"name":"self"}}],[11,"as_byte","","Converts an ASCII character into a `u8`.",0,null],[11,"as_char","","Converts an ASCII character into a `char`.",0,null],[11,"is_alphabetic","","Check if the character is a letter (a-z, A-Z)",0,null],[11,"is_digit","","Check if the character is a number (0-9)",0,null],[11,"is_alphanumeric","","Check if the character is a letter or number",0,null],[11,"is_blank","","Check if the character is a space or horizontal tab",0,null],[11,"is_whitespace","","Check if the character is a &#39; &#39;, &#39;\\t&#39;, &#39;\\n&#39; or &#39;\\r&#39;",0,null],[11,"is_control","","Check if the character is a control character",0,null],[11,"is_graph","","Checks if the character is printable (except space)",0,null],[11,"is_print","","Checks if the character is printable (including space)",0,null],[11,"is_lowercase","","Checks if the character is alphabetic and lowercase",0,null],[11,"is_uppercase","","Checks if the character is alphabetic and uppercase",0,null],[11,"is_punctuation","","Checks if the character is punctuation",0,null],[11,"is_hex","","Checks if the character is a valid hex digit",0,null],[11,"fmt","","",0,null],[11,"fmt","","",0,null],[11,"is_ascii","","",0,null],[11,"to_ascii_uppercase","","",0,null],[11,"to_ascii_lowercase","","",0,null],[11,"eq_ignore_ascii_case","","",0,null],[11,"make_ascii_uppercase","","",0,null],[11,"make_ascii_lowercase","","",0,null],[11,"eq","","",1,null],[11,"ne","","",1,null],[11,"fmt","","",1,null],[11,"fmt","","",1,null],[11,"description","","",1,null],[11,"to_ascii_char","","",0,null],[11,"to_ascii_char_unchecked","","",0,null],[11,"hash","","",2,null],[11,"cmp","","",2,null],[11,"partial_cmp","","",2,null],[11,"lt","","",2,null],[11,"le","","",2,null],[11,"gt","","",2,null],[11,"ge","","",2,null],[11,"eq","","",2,null],[11,"ne","","",2,null],[11,"new","","Coerces into an `AsciiStr` slice.",2,{"inputs":[{"name":"s"}],"output":{"name":"asciistr"}}],[11,"as_str","","Converts `&amp;self` to a `&amp;str` slice.",2,null],[11,"as_bytes","","Converts `&amp;self` into a byte slice.",2,null],[11,"as_slice","","Returns the entire string as slice of `AsciiChar`s.",2,null],[11,"as_mut_slice","","Returns the entire string as mutable slice of `AsciiChar`s.",2,null],[11,"as_ptr","","Returns a raw pointer to the `AsciiStr`&#39;s buffer.",2,null],[11,"as_mut_ptr","","Returns an unsafe mutable pointer to the `AsciiStr`&#39;s buffer.",2,null],[11,"to_ascii_string","","Copies the content of this `AsciiStr` into an owned `AsciiString`.",2,null],[11,"from_ascii","","Converts anything that can represent a byte slice into an `AsciiStr`.",2,{"inputs":[{"name":"b"}],"output":{"name":"result"}}],[11,"from_ascii_unchecked","","Converts anything that can be represented as a byte slice to an `AsciiStr` without checking\nfor non-ASCII characters..",2,{"inputs":[{"name":"b"}],"output":{"name":"asciistr"}}],[11,"len","","Returns the number of characters / bytes in this ASCII sequence.",2,null],[11,"is_empty","","Returns true if the ASCII slice contains zero bytes.",2,null],[11,"trim","","Returns an ASCII string slice with leading and trailing whitespace removed.",2,null],[11,"trim_left","","Returns an ASCII string slice with leading whitespace removed.",2,null],[11,"trim_right","","Returns an ASCII string slice with trailing whitespace removed.",2,null],[11,"eq","","",2,null],[11,"to_owned","","",2,null],[11,"as_ref","","",2,null],[11,"as_ref","","",2,null],[11,"as_ref","","",2,null],[11,"as_mut","","",2,null],[11,"fmt","","",2,null],[11,"fmt","","",2,null],[11,"index","","",2,null],[11,"index_mut","","",2,null],[11,"index","","",2,null],[11,"index_mut","","",2,null],[11,"index","","",2,null],[11,"index_mut","","",2,null],[11,"index","","",2,null],[11,"index_mut","","",2,null],[11,"index","","",2,null],[11,"index_mut","","",2,null],[11,"is_ascii","","",2,null],[11,"to_ascii_uppercase","","",2,null],[11,"to_ascii_lowercase","","",2,null],[11,"eq_ignore_ascii_case","","",2,null],[11,"make_ascii_uppercase","","",2,null],[11,"make_ascii_lowercase","","",2,null],[11,"fmt","","",3,null],[11,"eq","","",3,null],[11,"ne","","",3,null],[11,"clone","","",3,null],[11,"valid_up_to","","Returns the index of the first non-ASCII byte.",3,null],[11,"fmt","","",3,null],[11,"description","","Returns &quot;one or more bytes are not ASCII&quot;",3,null],[11,"as_ascii_str","","",2,null],[11,"as_ascii_str_unchecked","","",2,null],[11,"as_mut_ascii_str","","",2,null],[11,"as_mut_ascii_str_unchecked","","",2,null],[11,"hash","","",4,null],[11,"cmp","","",4,null],[11,"partial_cmp","","",4,null],[11,"lt","","",4,null],[11,"le","","",4,null],[11,"gt","","",4,null],[11,"ge","","",4,null],[11,"eq","","",4,null],[11,"ne","","",4,null],[11,"default","","",4,{"inputs":[],"output":{"name":"asciistring"}}],[11,"clone","","",4,null],[11,"new","","Creates a new, empty ASCII string buffer without allocating.",4,{"inputs":[],"output":{"name":"self"}}],[11,"with_capacity","","Creates a new ASCII string buffer with the given capacity.\nThe string will be able to hold exactly `capacity` bytes without reallocating.\nIf `capacity` is 0, the ASCII string will not allocate.",4,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"from_raw_parts","","Creates a new `AsciiString` from a length, capacity and pointer.",4,null],[11,"from_ascii_unchecked","","Converts a vector of bytes to an `AsciiString` without checking for non-ASCII characters.",4,{"inputs":[{"name":"b"}],"output":{"name":"self"}}],[11,"from_ascii","","Converts anything that can represent a byte buffer into an `AsciiString`.",4,{"inputs":[{"name":"b"}],"output":{"name":"result"}}],[11,"push_str","","Pushes the given ASCII string onto this ASCII string buffer.",4,null],[11,"capacity","","Returns the number of bytes that this ASCII string buffer can hold without reallocating.",4,null],[11,"reserve","","Reserves capacity for at least `additional` more bytes to be inserted in the given\n`AsciiString`. The collection may reserve more space to avoid frequent reallocations.",4,null],[11,"reserve_exact","","Reserves the minimum capacity for exactly `additional` more bytes to be inserted in the\ngiven `AsciiString`. Does nothing if the capacity is already sufficient.",4,null],[11,"shrink_to_fit","","Shrinks the capacity of this ASCII string buffer to match it&#39;s length.",4,null],[11,"push","","Adds the given ASCII character to the end of the ASCII string.",4,null],[11,"truncate","","Shortens a ASCII string to the specified length.",4,null],[11,"pop","","Removes the last character from the ASCII string buffer and returns it.\nReturns `None` if this string buffer is empty.",4,null],[11,"remove","","Removes the ASCII character at position `idx` from the buffer and returns it.",4,null],[11,"insert","","Inserts an ASCII character into the buffer at position `idx`.",4,null],[11,"len","","Returns the number of bytes in this ASCII string.",4,null],[11,"is_empty","","Returns true if the ASCII string contains zero bytes.",4,null],[11,"clear","","Truncates the ASCII string, setting length (but not capacity) to zero.",4,null],[11,"deref","","",4,null],[11,"deref_mut","","",4,null],[11,"eq","","",4,null],[11,"eq","","",4,null],[11,"ne","","",4,null],[11,"eq","","",4,null],[11,"ne","","",4,null],[11,"eq","","",4,null],[11,"ne","","",4,null],[11,"borrow","","",4,null],[11,"from","","",4,{"inputs":[{"name":"vec"}],"output":{"name":"self"}}],[11,"into","","",4,null],[11,"into","","",4,null],[11,"as_ref","","",4,null],[11,"as_mut","","",4,null],[11,"from_str","","",4,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"fmt","","",4,null],[11,"fmt","","",4,null],[11,"from_iter","","",4,{"inputs":[{"name":"i"}],"output":{"name":"asciistring"}}],[11,"from_iter","","",4,{"inputs":[{"name":"i"}],"output":{"name":"asciistring"}}],[11,"extend","","",4,null],[11,"extend","","",4,null],[11,"extend","","",4,null],[11,"add","","",4,null],[11,"index","","",4,null],[11,"index_mut","","",4,null],[11,"into_ascii_string_unchecked","","",4,null],[11,"into_ascii_string","","",4,null],[8,"ToAsciiChar","","Convert `char`, `u8` and other character types to `AsciiChar`.",null,null],[10,"to_ascii_char_unchecked","","Convert to `AsciiChar` without checking that it is an ASCII character.",5,null],[10,"to_ascii_char","","Convert to `AsciiChar`.",5,null],[8,"AsAsciiStr","","Convert slices of bytes to `AsciiStr`.",null,null],[10,"as_ascii_str_unchecked","","Convert to an ASCII slice without checking for non-ASCII characters.",6,null],[10,"as_ascii_str","","Convert to an ASCII slice.",6,null],[8,"AsMutAsciiStr","","Convert mutable slices of bytes to `AsciiStr`.",null,null],[10,"as_mut_ascii_str_unchecked","","Convert to a mutable ASCII slice without checking for non-ASCII characters.",7,null],[10,"as_mut_ascii_str","","Convert to a mutable ASCII slice.",7,null],[8,"IntoAsciiString","","Convert vectors into `AsciiString`.",null,null],[10,"into_ascii_string_unchecked","","Convert to `AsciiString` without checking for non-ASCII characters.",8,null],[10,"into_ascii_string","","Convert to `AsciiString`.",8,null]],"paths":[[4,"AsciiChar"],[3,"ToAsciiCharError"],[3,"AsciiStr"],[3,"AsAsciiStrError"],[3,"AsciiString"],[8,"ToAsciiChar"],[8,"AsAsciiStr"],[8,"AsMutAsciiStr"],[8,"IntoAsciiString"]]};
initSearch(searchIndex);
